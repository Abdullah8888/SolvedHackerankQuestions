//
//  main.swift
//  SolvedHackerankQuestions
//
//  Created by Jimoh Babatunde  on 18/05/2020.
//  Copyright Â© 2020 Jimoh Babatunde. All rights reserved.
//

import Foundation

print("Hello, World!")

//let dd = StairCaseAlgorithm()
//dd.formStairCase(n: 6)


//let result = checkMe("boo")
//print(result)

//let reust = filterFunction([4,5,8,3,7,12])
//print(reust)

//swapChars("book")
//ddf("book")
//getLargestNumber()

//chageLast3ToUpperCase()

//checkFirst4Ifis7()

//getNextLetterOfFirstOccurenceOfa()

//formStringFromLast2lettersOfString()

//formStringwithfirst2oftheGivenString()

//formStringWith2middleOfGivenString()

//checkfor3twice()

//let result = finalGrade(grades: [44,45,65,71,34])
//print(result)

//let result = lastQuestion("vwx", "ayx")
//print(result)testAdjacentArrayIntegers

//let result = testAdjacentArrayIntegers([4, 5, 6, 4, 3,5,9])
//print(result)

//let result = minimumSwaps([7,1,3,2,4,5,6])
//print(result)

//let result2 = minimumSwaps2([1,3,5,2,4,6,7])
//print(result2)

//let result2 = countValley(s: "DDUUDDUDUUUD")
//print(result2)

//let result2 = jumpingOnClouds(c: [0,0,0,1,0,0])
//print(result2)

//let result2 = jumpingOnClouds2(c: [0,0,0,1,0,0])
//print(result2)

//let result2 = jumpingOnClouds3(c: [0,0,1,0,0,1,0,])
//print(result2)
//let result2 = repeatedString(s: "cfimaakj", n: 554045874191)//138511468548
//print(result2)

//let result2 = beautifulDays(i: 20, j: 23, k: 6)
//print(result2)

//let result2 = rotLeft(a: [33, 47, 70, 37, 8, 53, 13, 93, 71, 72, 51, 100, 60, 87, 97], d: 13)//33 47 70 37 8 53 13 93 71 72 51 100 60 87 97     13
//print(result2
//give me one grand today night
//give one grand today
//two times three is not four
//two times two is four
//apgo clm w lxkvg mwz elo bg elo lxkvg elo apgo apgo w elo bg
//elo lxkvg bg mwz clm w
//checkMagazine(magazine: ["give", "me", "one", "grand", "today", "night"], note: ["give", "one", "grand", "today", "grand"])

//checkMagazine(magazine: ["give", "me", "one", "grand", "today", "nnight"], note: ["give", "one", "grand", "today", "gran"])
//arrayToDict()

//let result2 = twoStrings(s1: "hello hi", s2: "world world")
//print(result2)

//let result2 = binarySearch(array: [13, 21, 54, 81, 90], target: 21)
//print(result2)

//let isPalindrome = palindrome(stringInput: "live")
//print(isPalindrome)

//let result2 = jumpSearch(array: [0, 1, 1, 2, 3, 5, 8, 13, 21, 55, 77, 89, 101, 201, 256, 780], target: 21)
//print(result2)

//_ = addAll3([3,4,5])
//_ = addAll([3,4,5])

//tippleAndDoubleNumber(num1: "451999277", num2: "41177722899")
//suquareArray(totalArea: 12)

//convertToBinary(529)
//binaryGap()

//let number: String? = "01230"
//let result = number.flatMap{Int($0)}
//
//print(result)

//var a1 : Set<String> = ["h", "o", "t"]
//var a2 : Set<String> = ["d", "o", "g"]
//var a3 : Set<String> = []
//var ttt = ["aa" , "bb", "cc"]
//let dd = a2.intersection(a1)
//print(dd)
//let dff = a1.symmetricDifference(a2)
//print(dff)
//
//print(ttt)
//let fgt = ttt.reversed()
//
//tol: for (index, el) in fgt.enumerated() {
//    print(el)
//
//    if index == ttt.endIndex - 1 {
//        continue tol
//    }
//}

//let rr = "abca"
//let rre = rr.reduce(into: Set<String>()) { (curr, next) in
//    curr.insert(String(next))
//}
//let rre1 = rr.reduce(into: Set<String>()) { (curr, next) in
//    curr.insert(String(next))
//}
////let rre1 = rr.reduce(into: Set<String>(), { $0. })
//print(rre)
//print(rre1)
//let dfg = rre1
//if rre == rre1 {
//    print("yes")
//    print(dfg)
//}
//_ = rr.map{a3.insert($0.description)}
//print(a3)

//func ladderLength(_ beginWord: String, _ endWord: String, _ wordList: [String]) -> Int {
//    var countShortestTransform = 0
//    var wordListOfSet: [Set<String>] = []
//    if wordList.contains(endWord) {
//        for word in wordList {
//             let dd = word.reduce(into: Set<String>()) { (wordSet, element) in
//                    wordSet.insert(element.description)
//
//            }
//            wordListOfSet.append(dd)
//        }
//        print(wordListOfSet)
//    }
//   // print(<#T##items: Any...##Any#>)
//    return countShortestTransform
//
//}
//let gt = ladderLength("hit", "cog", ["hot","dot","dog","lot","log","cog"])
//print(gt)


//var a1 : Set<String> = ["p", "w", "w", "k", "e", "w"]
//var a2 : Set<String> = ["p", "w", "k", "e"]
//var cc = 1
//let index = a2.symmetricDifference(a1)
//print(index)
//let sd = "sdsf"

//putMe(true, ())
//putMe2(true, {_,_ in "sdsd"})

//dispatchTest()

//dictStuff()

//testStructAndClass()

//let pairsDivisibleby60Counter = numPairsDivisibleBy60([30,20,150,100,40])
//print(pairsDivisibleby60Counter)

//rawTest3()
//
//print(Int("a") as Any)
//
//if let ser = Int("0") {
//    print(ser)
//}
//
//var arrayTest = [3,5,6,4,3,6,3,3,3,34,3,54,4,3]
//var countTest:  [String] = []
//for (index, el) in arrayTest.enumerated() {
//    let nextIndex = index + 1
//    if nextIndex < arrayTest.count {
//        if arrayTest[index] == arrayTest[nextIndex] {
//            countTest.append("\(index+1) pair")
//            print("\(index) and \(nextIndex)")
//        }
//    }
//}
//print("counnt is \(countTest)")
//
let namesY = ["Harry", "Ron", "Hermione", "kon"]
var dfC = 0
//let dictNoteY = namesY.reduce(into: [String: Int]()) { (curr, next) in
//    dfC+=1
//    curr[next, default: 0] += dfC
//}
let scoreboard = namesY.reduce(into: [:]) { $0[$1] = 1 }

print(scoreboard)

let dictReduced = namesY.reduce(into: [Int : String]()) {(curr, next) in
    //dfC+=1
    var sd = curr[1, default: next]
}

print(dictReduced)



//var sd = [[9,9,4],[6,6,8],[2,1,1]]
//var ddf = sd.flatMap { $0}
////print(ddf.sorted())
//var s = [0]
//var s2 = [1]
////var st = s.removeAll {$0 == 0 }
//let index = s.index(s.startIndex, offsetBy: 1)
//var firstPart = Array(s[..<index])
//var secondPart = Array(s[index...])
////var ddd = Array(firstPart
//for index in 0..<1 {
//    if secondPart.isEmpty {
//        secondPart.append(s2[index])
//    }
//    else {
//        secondPart[index] = s2[index]
//    }
//
//}
//print(firstPart)
//print(secondPart)


//let dd = almostIncreasingSequence(sequence:[1, 2, 3, 4, 3, 6])
//print(dd)

//func matrixElementsSum(matrix: [[Int]]) -> Int {
//    var df = matrix.flatMap{$0}
//    print(df)
//    let ss = df.filter{ $0 != 0}
//    print(ss)
//    return 1
//}
//
//let matrix = [[1, 1, 1, 0],
//              [0, 5, 0, 1],
//              [2, 1, 3, 10]]
//_ = matrixElementsSum(matrix: matrix)
//
//
//var a11 : Set<String> = ["a","cd", "ss"]
//let ass = a11.reduce(into: Array()) { curr, next in
//    curr.append(next)
//}
//print(ass)

//let aaw = [[1,2,3],[8,4,5]]
//let dd5 = aaw.reduce([]){ $0 + $1}
//print(aaw.flatMap{$0})
//print(dd5)
//print(Array(aaw.joined()))
//print(aaw.map{$0})
//class AS {
//    var d = 4, y = 7
//}
//print("sadfasdf")
//func inc(b: Int) -> () -> Int {
//    var a = 0
//
//    func ss() -> Int {
//        a+=b
//        return a
//    }
//    return ss
//}
//
//let incTen = inc(b: 10)
//print(incTen())
//print(incTen())
//let incTen1 = inc(b: 5)
//print(incTen1())
//print(incTen1())

//let ddq = returnUnPairElement(array:[9, 3, 4, 3, 9, 5, 9, 5,5,4, 9])
//print(ddq)

//let res = returnXvalueIfpointAreSymmetric(dict: [1:1, 2:5, 4:5, 5:1, 3:0])
//print(res)

let yy = isAdmissibleOverpayment(prices: [110, 95, 70], notes:
["10.0% higher than in-store",
 "5.0% lower than in-store",
 "Same as in-store"], x: 5)
 print(yy)
let sd = "10.0% higher than in-store"
print(sd.split(separator: "%"))
